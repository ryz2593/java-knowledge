态类的关系，组合和聚合的区别、哪个关系更紧密？
说一下反射，及你在项目中的应用
Java反射是Java被视为动态（或准动态）语言的一个关键性质。JAVA反射机制是在运行状态中，对于任意一个类，
都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；
这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。

线程池，线程池参数
当我们需要的并发执行线程数量很多时，且每个线程执行很短的时间就结束了，这样，我们频繁的创建、销毁线程就大大降低了工作效率
（创建和销毁线程需要时间、资源）。
java中的线程池可以达到这样的效果：一个线程执行完任务之后，继续去执行下一个任务，不被销毁，这样线程利用率提高了。
1、corePoolSize：核心线程数
        * 核心线程会一直存活，及时没有任务需要执行
        * 当线程数小于核心线程数时，即使有线程空闲，线程池也会优先创建新线程处理
        * 设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭

2、queueCapacity：任务队列容量（阻塞队列）
	* 当核心线程数达到最大时，新任务会放在队列中排队等待执行

3、maxPoolSize：最大线程数
	* 当线程数>=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务
	* 当线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常

4、 keepAliveTime：线程空闲时间
	* 当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize
	* 如果allowCoreThreadTimeout=true，则会直到线程数量=0

5、allowCoreThreadTimeout：允许核心线程超时
6、rejectedExecutionHandler：任务拒绝处理器
	* 两种情况会拒绝处理任务：
		- 当线程数已经达到maxPoolSize，切队列已满，会拒绝新任务
		- 当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。
		  如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务
	* 线程池会调用rejectedExecutionHandler来处理这个任务。如果没有设置默认是AbortPolicy，会抛出异常
	* ThreadPoolExecutor类有几个内部实现类来处理这类情况：
		- AbortPolicy 丢弃任务，抛运行时异常
		- CallerRunsPolicy 执行任务
		- DiscardPolicy 忽视，什么都不会发生
		- DiscardOldestPolicy 从队列中踢出最先进入队列（最后一个执行）的任务
	* 实现RejectedExecutionHandler接口，可自定义处理器
线程池按以下行为执行任务
    1. 当线程数小于核心线程数时，创建线程。
    2. 当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。
    3. 当线程数大于等于核心线程数，且任务队列已满
        - 若线程数小于最大线程数，创建线程
        - 若线程数等于最大线程数，抛出异常，拒绝任务	

线程间的通信
方式一：使用 volatile 关键字
基于 volatile 关键字来实现线程间相互通信是使用共享内存的思想，大致意思就是多个线程同时监听一个变量，
当这个变量发生变化的时候 ，线程能够感知并执行相应的业务。这也是最简单的一种实现方式
方式二：使用Object类的wait() 和 notify() 方法
众所周知，Object类提供了线程间通信的方法：wait()、notify()、notifyaAl()，它们是多线程通信的基础，
而这种实现方式的思想自然是线程间通信。
 方式三：使用JUC工具类 CountDownLatch
jdk1.5之后在java.util.concurrent包下提供了很多并发编程相关的工具类，简化了我们的并发编程代码的书写，
***CountDownLatch***基于AQS框架，相当于也是维护了一个线程间共享变量state
方式五：基本LockSupport实现线程间的阻塞和唤醒
LockSupport 是一种非常灵活的实现线程间阻塞和唤醒的工具，使用它不用关注是等待线程先进行还是唤醒线程先运行，
但是得知道线程的名字。

介绍ThreadLocal
ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量
相对独立于其他线程内的变量。
ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。

可以总结为一句话：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，
减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。

举个例子，我出门需要先坐公交再做地铁，这里的坐公交和坐地铁就好比是同一个线程内的两个函数，我就是一个线程，
我要完成这两个函数都需要同一个东西：公交卡（北京公交和地铁都使用公交卡），
那么我为了不向这两个函数都传递公交卡这个变量（相当于不是一直带着公交卡上路），我可以这么做：将公交卡事先交给一个机构，
当我需要刷卡的时候再向这个机构要公交卡（当然每次拿的都是同一张公交卡）。这样就能达到只要是我(同一个线程)需要公交卡，
何时何地都能向这个机构要的目的。有人要说了：你可以将公交卡设置为全局变量啊，这样不是也能何时何地都能取公交卡吗？
但是如果有很多个人（很多个线程）呢？大家可不能都使用同一张公交卡吧(我们假设公交卡是实名认证的)，这样不就乱套了嘛。
现在明白了吧？这就是ThreadLocal设计的初衷：提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。

ConcurrentHashMap，JDK1.7和1.8的不同实现
其实可以看出JDK1.8版本的ConcurrentHashMap的数据结构已经接近HashMap，相对而言，
ConcurrentHashMap只是增加了同步的操作来控制并发，从JDK1.7版本的ReentrantLock+Segment+HashEntry，
到JDK1.8版本中synchronized+CAS+HashEntry+红黑树。

1.数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。
2.保证线程安全机制：JDK1.7采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。
JDK1.8采用CAS+Synchronized保证线程安全。
3.锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。
4.链表转化为红黑树:定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。
5.查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。

Hash算法
散列方法的主要思想是根据结点的关键码值来确定其存储地址：以关键码值K为自变量，通过一定的函数关系h(K)(称为散列函数)，
计算出对应的函数值来，把这个值解释为结点的存储地址，将结点存入到此存储单元中。检索时，用同样的方法计算地址，
然后到相应的单元里去取要找的结点。通过散列方法可以对结点进行快速检索。散列（hash，也称“哈希”）是一种重要的存储方式，
也是一种常见的检索方法。

什么是时间复杂度？
什么是时间复杂度，算法中某个函数有n次基本操作重复执行，用T(n)表示，现在有某个辅助函数f(n),使得当n趋近于无穷大时，
T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，
简称时间复杂度。通俗一点讲，其实所谓的时间复杂度，就是找了一个同样曲线类型的函数f(n)来表示这个算法的在n不断变大时的趋势 。
当输入量n逐渐加大时，时间复杂性的极限情形称为算法的“渐近时间复杂性”。 


问项目，项目中数据库的结构设计，整体框架等
用过数据库索引吗？介绍如何使用，何时使用？
数据库索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。
索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。

1、在作为主键的列上，强制该列的唯性和组织表中数据的排列结构，在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度，
而那些定义为text，image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少,不利于使用索引；
2、在经常需要搜索的列上，可以加快搜索的速度，在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的，
而那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。
相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求；　
3、在经常用在连接的列上，这些列主要是些外键，可以加快连接的速度，而只有很少数据值的列也不应该增加索引。
这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，
即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度；
4、在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间，
而当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，
但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改操作远远多于检索操作时，不应该创建索引。
根据以上4条数据库索引创建使用规则，弄清楚数据库中那些需要创建数据库索引的列，以及那些木有必要创建数据库索引的数据列的特点，
我们就可以正确合理的创建和使用数据库索引，才能有效的提高数据库整体运行性能及数据访问速度。

介绍B树、B+树、红黑树
B+树中只有叶子节点会带有指向记录的指针，而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。
B+树中所有叶子节点都是通过指针连接在一起，而B树不会。
B+树优点：
1. 非叶子节点不会带上指向记录的指针，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。
2. 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停地往返移动。
具体的讲，如何向扫描一次所有的数据，对于b+树来说，因为他们的叶子节点是连在一起的，所以可以横向的遍历过去。而对于b树来说，就只能中序遍历了。
B树的优点：
对于在内部节点的数据，可以直接得到，不必根据叶子节点来定位。
红黑树的规则：
1. 每个节点要么是红的，要么是黑的
2. 根节点是黑的
3. 每个叶节点（叶节点即指树尾端NIL指针或NULL结点）是黑的
4. 如果一个结点是红的，那么他的两个儿子都是黑的。
5. 对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。
数据库分页查询，如何分页，怎么实现？
四种隔离级别，虚读和幻读什么意思发生在哪？
Read uncommitted(未授权读取、读未提交)：会出现脏读
Read committed（授权读取、读提交）：会出现不可重复读
Repeatable read（可重复读取）：会出现幻读（默认隔离级别）
Serializable（序列化）：

脏读：指在一个事务处理过程里读取了另一个未提交的事务中的数据，读取数据不一致。
不可重复读：是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，
被另一个事务修改并提交了。
虚读(幻读)：第一个事务A对一定范围的数据进行批量修改，第二个事务B在这个范围增加一条数据，
这时候第一个事务就会丢失对新增数据的修改。

不可重复读和脏读的区别：脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。　　
幻读和不可重复读区别：幻读是针对插入操作的(表级别锁)，不可重复度是针对更新和删除操作的(行级别锁)。

使用的MySQL版本，和之前版本的区别
使用什么版本的JDK（我答1.8）介绍和之前版本的不同
1.7和1.8的JVM有哪些不同？
1.8的垃圾回收算法，介绍你所知道的垃圾回收算法，CMS垃圾回收器简单介绍
ConcurrentHashMap的size()函数1.7和1.8的不同，或者介绍一下如果是你如何设计
排序算法，介绍一下快速排序，快速排序时间复杂度，是不是稳定排序，介绍几种你所知道的稳定排序算法
UDP，TCP，HTTP介绍一下，OSI七层模型
Java的锁机制
死锁产生的原因
说说Spring的生命周期吧
说说GC的过程
强制young gc会有什么问题？
知道G1么？ 回收过程是怎么样的？ 你提到的Remember Set底层是怎么实现的？
CMS GC有什么问题？
怎么避免产生浮动垃圾？
算法题：（1）最大子序列和；（2）反转链表；（3）数组中查找两数之和为K的序列对
分布式追踪的上下文是怎么存储和传递的？
SpringMVC不同用户登录的信息怎么保证线程安全的？
我们聊聊mysql吧，说下索引结构，为什么使用B+树？
Dubbo的RpcContext是怎么传递的？主线程的ThreadLocal怎么传递到线程池？你说的内存泄漏具体是怎么产生的？
线程池的线程是不是必须手动remove才可以回收value？那你说的内存泄漏是指主线程还是线程池？
什么是索引覆盖？
索引是高效找到行的一个方法,当能通过检索索引就可以读取想要的数据,那就不需要再到数据表中读取行了。
如果一个索引包含了(或覆盖了)满足查询语句中字段与条件的数据就叫做覆盖索引。
Java为什么要设计双亲委派模型？
 双亲委派模式的工作原理的是;
 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，
 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，
 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，
 子加载器才会尝试自己去加载，这就是双亲委派模式。
 好处：
 采用双亲委派模式的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层次关系可以避免类的重复加载，
 当父类已经加载了该类时，就没有必要子ClassLoader再加载一次。
 其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，
 通过双亲委派模型传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类已经被加载，
 并不会重新加载网络传递过来的java.lang.Integer，而是直接返回已经加载过你的Integer.class，
 这样便可以放置核心API库被随意篡改。
什么时候需要自定义类加载器？
主要是由于Java默认的类加载器只能加载本地的类文件，这与java的网络特性非常的不合，
因此，有必要根据需要修改java的类加载器方便的从网络加载类文件。
做题：手写一个对象池
