态类的关系，组合和聚合的区别、哪个关系更紧密？
说一下反射，及你在项目中的应用
Java反射是Java被视为动态（或准动态）语言的一个关键性质。JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。

线程池，线程池参数
当我们需要的并发执行线程数量很多时，且每个线程执行很短的时间就结束了，这样，我们频繁的创建、销毁线程就大大降低了工作效率（创建和销毁线程需要时间、资源）。
java中的线程池可以达到这样的效果：一个线程执行完任务之后，继续去执行下一个任务，不被销毁，这样线程利用率提高了。
1、corePoolSize：核心线程数
        * 核心线程会一直存活，及时没有任务需要执行
        * 当线程数小于核心线程数时，即使有线程空闲，线程池也会优先创建新线程处理
        * 设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭

2、queueCapacity：任务队列容量（阻塞队列）
	* 当核心线程数达到最大时，新任务会放在队列中排队等待执行

3、maxPoolSize：最大线程数
	* 当线程数>=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务
	* 当线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常

4、 keepAliveTime：线程空闲时间
	* 当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize
	* 如果allowCoreThreadTimeout=true，则会直到线程数量=0

5、allowCoreThreadTimeout：允许核心线程超时
6、rejectedExecutionHandler：任务拒绝处理器
	* 两种情况会拒绝处理任务：
		- 当线程数已经达到maxPoolSize，切队列已满，会拒绝新任务
		- 当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务
	* 线程池会调用rejectedExecutionHandler来处理这个任务。如果没有设置默认是AbortPolicy，会抛出异常
	* ThreadPoolExecutor类有几个内部实现类来处理这类情况：
		- AbortPolicy 丢弃任务，抛运行时异常
		- CallerRunsPolicy 执行任务
		- DiscardPolicy 忽视，什么都不会发生
		- DiscardOldestPolicy 从队列中踢出最先进入队列（最后一个执行）的任务
	* 实现RejectedExecutionHandler接口，可自定义处理器
线程池按以下行为执行任务
    1. 当线程数小于核心线程数时，创建线程。
    2. 当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。
    3. 当线程数大于等于核心线程数，且任务队列已满
        - 若线程数小于最大线程数，创建线程
        - 若线程数等于最大线程数，抛出异常，拒绝任务	

线程间的通信
Java中线程通信协作的最常见的两种方式：

　　一.syncrhoized加锁的线程的Object类的wait()/notify()/notifyAll()

　　二.ReentrantLock类加锁的线程的Condition类的await()/signal()/signalAll()

　　线程间直接的数据交换：

　　三.通过管道进行线程间通信：1）字节流；2）字符流  　

介绍ThreadLocal
ConcurrentHashMap，JDK1.7和1.8的不同实现
Hash算法
什么是时间复杂度？
问项目，项目中数据库的结构设计，整体框架等
用过数据库索引吗？介绍如何使用，何时使用？
介绍B树、B+树、红黑树
数据库分页查询，如何分页，怎么实现？
四种隔离级别，虚读和幻读什么意思发生在哪？
使用的MySQL版本，和之前版本的区别
使用什么版本的JDK（我答1.8）介绍和之前版本的不同
1.7和1.8的JVM有哪些不同？
1.8的垃圾回收算法，介绍你所知道的垃圾回收算法，CMS垃圾回收器简单介绍
ConcurrentHashMap的size()函数1.7和1.8的不同，或者介绍一下如果是你如何设计
排序算法，介绍一下快速排序，快速排序时间复杂度，是不是稳定排序，介绍几种你所知道的稳定排序算法
UDP，TCP，HTTP介绍一下，OSI七层模型
Java的锁机制
死锁产生的原因
说说Spring的生命周期吧
说说GC的过程
强制young gc会有什么问题？
知道G1么？ 回收过程是怎么样的？ 你提到的Remember Set底层是怎么实现的？
CMS GC有什么问题？
怎么避免产生浮动垃圾？
算法题：（1）最大子序列和；（2）反转链表；（3）数组中查找两数之和为K的序列对
分布式追踪的上下文是怎么存储和传递的？
SpringMVC不同用户登录的信息怎么保证线程安全的？
我们聊聊mysql吧，说下索引结构，为什么使用B+树？
Dubbo的RpcContext是怎么传递的？主线程的ThreadLocal怎么传递到线程池？你说的内存泄漏具体是怎么产生的？
线程池的线程是不是必须手动remove才可以回收value？那你说的内存泄漏是指主线程还是线程池？
什么是索引覆盖？
Java为什么要设计双亲委派模型？
什么时候需要自定义类加载器？
做题：手写一个对象池
