Redis缓存的使用，极大的提高了应用程序的性能和效率，特别是在数据查询方面。但同时也带来了一定的问题，其中最要害的问题就是数据一致性问题。严格意义上讲这个问题是无解的。如果对数据一致性要求很高，那么就不能使用缓存。

**缓存穿透**

缓存穿透，是指查询一个数据库一定不存在的数据。正常的使用缓存流程大致是，数据查询先进行缓存查询，如果key不存在或者key已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存。

**缓存雪崩**

缓存雪崩，是指在某一个时间段（较短的时间范围内），缓存集中（大量）过期失效。

解决方案（道）：

1. 更多的页面静态化处理。

2. 构建多级缓存架构

    Nginx缓存+redis缓存+ehcache缓存

3. 监测MySQL严重耗时业务进行优化

    对数据库的瓶颈进行排查：例如超时查询、耗时较高事务等
4. 灾难预警机制
    
    监控redis服务器性能指标
    - CPU占用、CPU使用率
    - 内存容量
    - 查询平均响应时长
    - 线程数        
5. 限流、降级
    
    短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后在逐步开放访问
        
解决方案（术）：
1. LRU与LFU切换
2. 数据有效期策略调整
    - 根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟
    - 过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量
3. 超热数据使用永久key
4. 定期维护（自动+人工）
    
    对即将过期数据做访问量分析，确认是否延时，配方访问量统计，做热点数据的延时
5. 加锁
    
    慎用！        




**缓存击穿**

缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。

可以使用互斥锁，一个线程去访问数据库，其他的线程进行等待，这样不会增加数据库的访问压力。

**RedisTemplate和StringRedisTemplate的区别**

1. 两者的关系是StringRedisTemplate继承RedisTemplate.

2. 两者的数据是部共通的；也就是说StringRedisTemplate只能管理StringRedisTemplate里面的数据，RedisTemplate只能管理RedisTemplate里面的数据。

3. SDR默认采用的序列化策略有两种，一种是String的序列化策略，一种是JDK的序列化策略。

StringRedisTemplate默认采用的是String的序列化策略，保存的key和value都是采用此策略序列化保存的。

RedisTemplate默认采用的是JDK的序列化策略，保存的key和value都是采用此策略序列化保存的。

总结：

当你的redis数据库里面本来存的是字符串数据或者你要存取的数据就是字符串类型数据的时候，那么你就使用StringRedisTemplate即可，但是如果你的数据是复杂的对象类型，而取出的时候又不想做任何的数据转换，直接从Redis里面取出一个对象，那么使用RedisTemplate是更好的选择。

**Redis深度历险**

**1. 有人说Redis只适合用来做缓存，当数据库来用则不合适，你怎么看？**

**Redis能否做数据库用取决于以下几个条件：**

1. 数据量: redis是内存数据库，要受限于内存的容量。

2. 数据的结构：是否能够将关系型数据结构都转换成key/value的形式

3. 查询的效率：对范围查询等，是否能转换为搞笑的hash索引查询

**Redis能不能用来当数据库，取决于你想要存储什么数据：**

如果你打算存储一些临时数据，数据规模不大，不需要太复杂的查询，但是要求性能比较高，这种情况下是可以当数据库使用的。

**能否用来做数据库，要看具体的需求：**

1. redis的持久化有问题，如果使用的是aof模式，并且设置的是fsync always方式，那么性能会很低，如果数据结构非常适用于适用redis存储并且对性能要求不高，或者对性能要求很高但允许一定程度的丢失数据，则可以。

2. redis数据都是存储在内存中的，如果内存满了，数据就不会存储到硬盘上了。

redis是一种key/value的内存数据库，项目里基本上都是用来做缓存的，可以对数据设置过期时间，时间到了之后就会被清理掉。

**2. 为什么Redis先执行指令，之后在记录AOF日志，而不是像其他存储引擎一样反过来呢？**

因为Redis会在收到客户端修改指令后，进行参数校验、逻辑处理，如果没有问题，就立即将该指令文本存储到AOF日志中，也就是说，先执行指令才将日志存盘。
如果反过来，则可能会存入很多无效的指令（或者错误指令）。

<h1>redis哨兵机制</h1>
哨兵（sentinel）是一个分布式系统，用于对主从结构中的每台服务器进行监控，当出现故障时通过投票机制选择新的master并将所有的slave连接到新的master

哨兵的作用：
- 监控

   不断地检查master和slave是否正常运行。
   
   master存货监测、master与slave运行情况监测。 
- 通知（提醒）

    当被监控的服务器出现问题时，像其他（哨兵间，客户端）发送通知
- 自动故障转移

    断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址。
    
哨兵的工作原理：

阶段一：监控阶段

    - 用于同步各个节点的信息
        - 获取各个sentinel的状态（是否在线）
        - 获取master的信息
            - master属性
                - runid
                - role: master
            - 各个slave的详细信息
        - 获取所有slave的状态（根据master中的slave信息）
            - slave属性
                - runid
                - role: slave
                - master_host、master_port
                - offset
                ...                        
阶段二：通知阶段

    sentinel1（也可能是其他的sentinel结点）会定时的去监测master、slave节点状态
    然后在sentinel形成的圈子里面传播这个信息，各个sentinel节点之间会进行消息共享

阶段三：故障转移阶段
    
    sentinel1会去向master定期发送hello，看master是否正常，如果master一直么有相应（设置的时间默认是30秒），sentinel1就会在sentinel所在的圈子里发送一条指令说master挂了，然后将master标记为sdonwn（主观下线）
    其他的sentinel就回去尝试连接master，如果都认为（通常设置的是一半+1个）master已经下线了，就会将master标记为odown（客观下线）。
    
    一旦标记为客观下线就会清理队伍了
    首先sentinel中会先投票选出一个sentinel来进行清理任务
    被选出来的sentinel来进行一下工作
    - 服务器列表中挑选备选master
        - 在线的
        - 响应慢的（不要）
        - 与原master断开时间久的（不要）
        - 优先原则
            - 优先级
            - offset（看那个slave结点同步的更多）
            - runid （先启动的redis实例，runid会小一些，相当于优先选用最先启动的redis实例）
    - 发送指令（sentinel）
        - 向新的master发送slaveof no one
        - 向其他的slave发送slaveof新masterIP端口
                    
# 集群

**集群的作用**    
- 分散单台服务器的压力，实现负载均衡
- 分散单台服务器的存储压力，实现可扩展
- 降低单台服务器宕机带来的业务灾难
   
**Redis集群的结构设计**
 
**数据存储设计**   
- 通过算法设计，计算出key应该保存的位置
- 将所有的存储空间计划切割成16384份，每台主机保存一部分
    
    每份代表的是一个存储空间，不是一个key的保存空间
- 将key按照计算出的结果放到对应的存储空间
       

**缓存预热**
就是在系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查找数据库，然后在将数据缓存的问题。
用户直接查询事先被预热的缓存数据。



1. 什么是热点数据?
1). 客户端收集日志
2). 服务器端收集日志
3). 第三方收集日志 elasticsearch

2. 如何导入到redis中?
pinpline管道操作 一次可以完成多次输入 

3. 如何保证redis和数据库一致性?

加锁一致性，双删延迟+数据设置过期时间

4. 如何存储，用什么数据结构比较合适，避免大value，如何进行拆分?

5. 分析redis为什么慢？慢查询

6. Redis性能是否好？如何解决
redis-benchmark




























